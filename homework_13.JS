// Напишіть функцію, яка рекурсивно обчислює n-те число Фібоначчі. Числа Фібоначчі визначаються як послідовність, у якій кожне число дорівнює сумі двох попередніх чисел (наприклад, 0, 1, 1, 2, 3, 5, 8 і так далі). Використовуйте рекурсію для обчислення чисел Фібоначчі.

function fib(n){
    return n <= 1 ? n : fib(n - 2) + fib(n - 1)
}

// Попрацюємо з числовим паліндромом. Числовий паліндром — це натуральне число, яке читається зліва направо і справа наліво однаково. Інакше кажучи, відрізняється симетрією запису (розташування цифр), причому число знаків може бути як парним, так і непарним. Але. Паліндром можна отримати як результат операцій над іншими числами. Візьмемо будь-яке натуральне число і складемо його зі зворотним числом, тобто записаним тими самими цифрами, але у зворотному порядку. Проробимо ту саму дію з сумою, що вийшла, і будемо повторювати її доти, доки не утвориться паліндром. Іноді достатньо зробити всього один крок (наприклад, 312 + 213 = 525), але, як правило, потрібно не менше двох. Скажімо, число 96 породжує паліндром 4884 тільки на четвертому кроці.... Вам потрібно написати функцію, яка повертатиме об'єкт, де буде властивість result і це буде паліндром, і властивість steps — це число викликів до знаходження паліндрома. Для того, щоб перевірити себе використовуйте число 196. Це так зване Lychrel number — число яке немає поліндрому

function isPalindromeNumber(x){
    let y = x;

    let myObj = {
        result: '',
        steps: 0
    }

    function palindrome(y){

        let rev = [...y.toString()].map(Number).reverse().join('');
        let j = + rev + y;
        let i = [...j.toString()].map(Number).reverse().join('')

        if (j == i){
            myObj.result = j;
        } else {
            y = j
            palindrome(j);
            myObj.steps += 1;
        }
    }
    palindrome(y);
    
    return myObj;
}

console.log(isPalindromeNumber(96))
console.log(isPalindromeNumber(46))

// Напишіть функцію, яка приймає масив унікальних елементів і генерує всі можливі перестановки цього масиву. Використовуйте рекурсію для знаходження всіх перестановок. Наприклад, якщо вхідний масив [1, 2, 3], функція має повернути масив, що містить [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [2, 3, 1], [3, 1, 2] і [3, 2, 1].

function isArray(args){
    let permArr = [],
    usedChars = [];
  
    function getVariants(args) {
        let i, ch;
        for (i = 0; i < args.length; i++) {
            ch = args.splice(i, 1)[0];
            usedChars.push(ch);
        if (args.length == 0) {
            permArr.push(usedChars.slice());
        }
        getVariants(args);
        args.splice(i, 0, ch);
        usedChars.pop();
        }
        return permArr
    };
    getVariants(args);
    return permArr
}

console.log(isArray([96, 1, 2, 3]))

